#!/usr/bin/env node
(function(e){var n={};function __webpack_require__(t){if(n[t]){return n[t].exports}var r=n[t]={i:t,l:false,exports:{}};e[t].call(r.exports,r,r.exports,__webpack_require__);r.l=true;return r.exports}__webpack_require__.m=e;__webpack_require__.c=n;__webpack_require__.d=function(e,n,t){if(!__webpack_require__.o(e,n)){Object.defineProperty(e,n,{enumerable:true,get:t})}};__webpack_require__.r=function(e){if(typeof Symbol!=="undefined"&&Symbol.toStringTag){Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}Object.defineProperty(e,"__esModule",{value:true})};__webpack_require__.t=function(e,n){if(n&1)e=__webpack_require__(e);if(n&8)return e;if(n&4&&typeof e==="object"&&e&&e.__esModule)return e;var t=Object.create(null);__webpack_require__.r(t);Object.defineProperty(t,"default",{enumerable:true,value:e});if(n&2&&typeof e!="string")for(var r in e)__webpack_require__.d(t,r,function(n){return e[n]}.bind(null,r));return t};__webpack_require__.n=function(e){var n=e&&e.__esModule?function getDefault(){return e["default"]}:function getModuleExports(){return e};__webpack_require__.d(n,"a",n);return n};__webpack_require__.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)};__webpack_require__.p="";return __webpack_require__(__webpack_require__.s=5)})([function(e,n){e.exports=require("fs")},function(e,n){e.exports=require("path")},function(e,n){e.exports=require("child_process")},function(e,n,t){"use strict";t.d(n,"b",(function(){return assertIsString}));t.d(n,"c",(function(){return assertIsStringArray}));t.d(n,"a",(function(){return assertHasFields}));const assertIsString=(e,n)=>{if(typeof n!=="string"){throw new Error(`Expect '${e}' to be a string!`)}return n};const assertIsStringArray=(e,n,t=false)=>{if(t&&n==null){return[]}if(n==null||!Array.isArray(n)){throw new Error(`Expect '${e}' to be a string array!`)}const r=n.filter(e=>typeof e==="string");if(r.length!==n.length){throw new Error(`Expect '${e}' to be a string array!`)}return r};const assertHasFields=(e,n,t)=>{if(t==null){throw new Error(`Expect '${e}' to be an object, but got undefined or null!`)}if(typeof t!=="object"){throw new Error(`Expect '${e}' to be an object, but got ${typeof t}!`)}const r={};const o=n.filter(e=>{const n=t[e];if(n!=null){r[e]=n}return n==null});if(o.length>0){throw new Error(`'${e}' has missing fields: [${o.join(", ")}]`)}return r}},function(e,n,t){"use strict";t.r(n);t.d(n,"PROJECT_ROOT_DIRECTORY",(function(){return a}));t.d(n,"PROJECT_CONFIGURATION",(function(){return l}));var r=t(0);var o=t.n(r);var c=t(1);var s=t.n(c);var i=t(3);const parseRepoToolsConfiguration=e=>{const{binary:n,organizationName:t,toolingPrefixes:r,deploymentSecrets:o}=Object(i["a"])("repoToolsConfiguration",["binary","organizationName","toolingPrefixes","deploymentSecrets"],e);return{binary:Object(i["b"])("binary",n),organizationName:Object(i["b"])("organizationName",t),toolingPrefixes:Object(i["c"])("toolingPrefixes",r),deploymentSecrets:Object(i["c"])("deploymentSecrets",o)}};const loadRepoToolsConfigurationAndFindRoot=()=>{let e=process.cwd();while(e!=="/"){const n=Object(c["join"])(e,"package.json");if(Object(r["existsSync"])(n)&&Object(r["lstatSync"])(n).isFile()){const t=JSON.parse(Object(r["readFileSync"])(n).toString());if(Array.isArray(t.workspaces)){return[e,parseRepoToolsConfiguration(t.repoToolsConfiguration)]}}e=Object(c["dirname"])(e)}throw new Error("No configuration found. Abort!")};const[a,l]=loadRepoToolsConfigurationAndFindRoot()},function(e,n,t){e.exports=t(6)},function(e,n,t){"use strict";t.r(n);var r=t(2);var o=t(0);var c=t(1);var s=t(3);const assertIsLibraryType=e=>{if(e==null)return"library";const n=Object(s["b"])("packageType",e);if(n!=="tool"&&n!=="app")throw new Error("");return n};const validateCodegenConfiguration=e=>({output:Object(s["b"])("output",Object(s["a"])("codegenConfiguration",["output"],e).output)});const queryYarnForWorkspaceInformation=()=>{const e=new Map;const n=Object(r["spawnSync"])("yarn",["workspaces","list","-v","--json"]);const t=n.stdout.toString().trim();const i=`[${t.split("\n").join(",")}]`;const a=JSON.parse(i);a.forEach(({name:n,location:t,workspaceDependencies:r})=>{var i;if(n==null){return}const a=r.map(e=>{if(!e.startsWith("packages/")){throw new Error(`Bad dependency of ${n}: ${e}`)}return e.substring("packages/".length)});const l=JSON.parse(Object(o["readFileSync"])(Object(c["join"])(t,"package.json")).toString());e.set(n,{workspaceLocation:t,hasCompileScript:((i=l.scripts)===null||i===void 0?void 0:i.compile)!=null,inRepoWorkspaceDependencies:a,packageType:assertIsLibraryType(l.packageType),deploymentDependencies:Object(s["c"])("deploymentDependencies",l.deploymentDependencies,true),codegenConfiguration:l.codegenConfiguration==null?undefined:validateCodegenConfiguration(l.codegenConfiguration)})});return e};var i=queryYarnForWorkspaceInformation;const a=i();const l=Array.from(a.keys());const getWorkspaceInformation=e=>{const n=a.get(e);if(n==null){throw new Error(`Workspace ${e} is not found!`)}return n};const getYarnWorkspaceLocation=e=>getWorkspaceInformation(e).workspaceLocation;const getYarnWorkspaceHasCompileScript=e=>getWorkspaceInformation(e).hasCompileScript;const getYarnWorkspacePackageType=e=>getWorkspaceInformation(e).packageType;const getYarnWorkspaceInRepoDependencyChain=e=>{const n=[];const t=[];const r=new Set;const o=new Set;const visit=e=>{if(o.has(e)){if(!r.has(e)){return}t.push(e);const n=t.indexOf(e);const o=t.slice(n,t.length).join(" -> ");throw new Error(`Cyclic dependency detected: ${o}`)}const c=getWorkspaceInformation(e).inRepoWorkspaceDependencies;o.add(e);t.push(e);r.add(e);c.forEach(visit);r.delete(e);t.pop();n.push(e)};visit(e);return n};const getYarnWorkspacesInTopologicalOrder=()=>{const e=[];const n=new Set;Array.from(a.keys()).forEach(t=>{const r=getYarnWorkspaceInRepoDependencyChain(t);r.forEach(t=>{if(!n.has(t)){e.push(t);n.add(t)}})});return e};const getYarnWorkspaceDeploymentDependencies=e=>getWorkspaceInformation(e).deploymentDependencies;const singleSourceNeedsRebuild=(e,n)=>Object(o["statSync"])(e).mtime.getTime()>=n;const singleWorkspaceSourcesNeedRebuild=(e,n,t)=>{const recursiveVisit=e=>{if(n.includes(e))return false;if(Object(o["lstatSync"])(e).isFile())return singleSourceNeedsRebuild(e,t);return Object(o["readdirSync"])(e).some(n=>recursiveVisit(Object(c["join"])(e,n)))};const r=Object(c["resolve"])(e);return recursiveVisit(r)};const workspaceNeedRebuild=(e,n,t)=>getYarnWorkspaceInRepoDependencyChain(e).map(getYarnWorkspaceLocation).some(e=>singleWorkspaceSourcesNeedRebuild(e,n,t));var u=workspaceNeedRebuild;const sourcesNeedRebuild=(e,n,t)=>{const r=Object(c["resolve"])(Object(c["join"])(n,t));return u(e,[r],Object(o["existsSync"])(r)?Object(o["statSync"])(r).mtime.getTime():0)};const cachedBuildTargetDeterminator=()=>Array.from(a.entries()).filter(([e,{workspaceLocation:n,codegenConfiguration:t}])=>t!=null&&sourcesNeedRebuild(e,n,t.output)).map(([e])=>e);var p=cachedBuildTargetDeterminator;const cachedBuild=async()=>{console.log("--- Monorail Cached Build Service ---");const e=p();if(e.length===0){console.log("[✓] No need to rebuild!");return}console.group(`[${e.join(", ")}] needs to be rebuilt!`);const n=e.map(e=>{console.log(`Rebuiding \`${e}\`...`);return[e,Object(r["spawnSync"])("yarn",["workspace",e,"codegen"],{stdio:["inherit",process.env.INCLUDE_ERROR?"inherit":"ignore","inherit"]}).status===0]});console.groupEnd();const t=n.filter(([,e])=>!e).map(([e])=>e);if(t.length===0){console.log("[✓] All workspaces have been successfully rebuilt!");return}throw new Error(`[x] [${t.join(", ")}] failed to exit with 0`)};var d=cachedBuild;const parseCommandLineArgumentsIntoCommand=()=>{const e=process.argv.slice(2);if(e.length===0){return"CODEGEN"}switch(e[0].toLowerCase()){case"codegen":return"CODEGEN";case"compile":case"c":return"COMPILE";case"no-changed":case"nc":return"NO_CHANGED";case"rebuild":case"r":return"REBUILD";case"sync":case"s":return"SYNC";default:throw new Error(`Unknown command: ${e[0]}`)}};var g=parseCommandLineArgumentsIntoCommand;var f=t(4);const githubActionJobActionStep=(e,n={})=>({type:"use-action",actionName:e,actionArguments:n});const githubActionJobRunStep=(e,n)=>({type:"run",stepName:e,command:n});const githubActionJobStepToString=e=>{switch(e.type){case"use-action":{const n=`      - uses: ${e.actionName}\n`;if(Object.keys(e.actionArguments).length===0){return n}const t=Object.entries(e.actionArguments).map(([e,n])=>{const t=n.split("\n");if(t.length===1){return`          ${e}: ${t[0]}`}return`          ${e}: |\n${t.map(e=>`            ${e}`).join("\n")}`}).join("\n");return`${n}        with:\n${t}\n`}case"run":{const n=`      - name: ${e.stepName}\n`;const t=e.command.split("\n");if(t.length===1){return`${n}        run: ${t[0]}\n`}return`${n}        run: |\n${t.map(e=>`          ${e}\n`).join("")}`}default:throw new Error}};const githubActionJobToString=({jobName:e,jobSteps:n})=>`  ${e}:\n    runs-on: ubuntu-latest\n    steps:\n${n.map(githubActionJobStepToString).join("")}`;const githubActionWorkflowToString=({workflowName:e,workflowtrigger:{triggerPaths:n,masterBranchOnly:t},workflowSecrets:r=[],workflowJobs:o})=>{const c=`# @generated\n\nname: ${e}\non:\n  push:\n    paths:\n${n.map(e=>`      - '${e}'\n`).join("")}${t?`    branches:\n      - master\n`:""}${r.length>0?`env:\n${r.map(e=>`  ${e}: \${{ secrets.${e} }}`).join("\n")}\n`:""}\njobs:\n${o.map(githubActionJobToString).join("")}`;return c};const b=githubActionJobActionStep("actions/checkout@v2");const m=githubActionJobActionStep("actions/setup-node@v2-beta");const y=githubActionJobActionStep("actions/cache@v2",{path:".yarn/cache\n.pnp.js",key:"yarn-berry-${{ hashFiles('**/yarn.lock') }}","restore-keys":"yarn-berry-"});const w=githubActionJobRunStep("Install firebase-tools","sudo npm install -g firebase-tools");const getDeploymentDependencySetupStep=e=>{switch(e){case"firebase-tools":return w;default:throw new Error(`Unsupported deployment dependency: ${e}`)}};const h=[b,m,y,githubActionJobRunStep("Yarn Install","yarn install --immutable")];const yarnWorkspaceGetDependencyPaths=e=>[...getYarnWorkspaceInRepoDependencyChain(e).map(e=>`${getYarnWorkspaceLocation(e)}/**`),"configuration/**",`.github/workflows/generated-*-${e}.yml`];const generateYarnWorkspaceProjectCDWorkflow=e=>({workflowName:`CD ${e}`,workflowtrigger:{triggerPaths:yarnWorkspaceGetDependencyPaths(e),masterBranchOnly:true},workflowSecrets:f["PROJECT_CONFIGURATION"].deploymentSecrets,workflowJobs:[{jobName:"deploy",jobSteps:[...h,githubActionJobRunStep("Build",`yarn workspace ${e} build`),...getYarnWorkspaceDeploymentDependencies(e).map(getDeploymentDependencySetupStep),githubActionJobRunStep("Deploy",`yarn workspace ${e} deploy`)]}]});const getYarnWorkspaceWorkflows=()=>Object.fromEntries([...l.filter(e=>getYarnWorkspacePackageType(e)==="app").map(e=>{const n=`cd-${e}`;return[n,generateYarnWorkspaceProjectCDWorkflow(e)]})]);const generateTSJSWorkflow=()=>["ts-js",{workflowName:"TS and JS",workflowtrigger:{triggerPaths:[".github/workflows/generated-ts-js.yml","package.json","**/package.json","**.js","**.ts","**.jsx","**.tsx"],masterBranchOnly:false},workflowJobs:[{jobName:"lint",jobSteps:[...h,githubActionJobRunStep("Format Check","yarn format:check"),githubActionJobRunStep("Lint","yarn lint")]},{jobName:"build",jobSteps:[githubActionJobActionStep("actions/checkout@v2",{"fetch-depth":"2"}),m,y,githubActionJobRunStep("Yarn Install","yarn install --immutable"),githubActionJobRunStep("Build","yarn compile")]},{jobName:"test",jobSteps:[...h,githubActionJobRunStep("Test","yarn test")]}]}];const generateCodegenPorcelainWorkflow=()=>["generated-in-sync",{workflowName:"lint-generated",workflowtrigger:{triggerPaths:["**"],masterBranchOnly:false},workflowJobs:[{jobName:"lint",jobSteps:[b,m,githubActionJobRunStep("Codegen",`${f["PROJECT_CONFIGURATION"].binary} codegen`),githubActionJobRunStep("Check changed",`${f["PROJECT_CONFIGURATION"].binary} no-changed`)]}]}];const j={serviceName:"Generate GitHub Actions Workflow",generatedFilenamePattern:".github/workflows/generated-*",generatedCodeContentList:[generateTSJSWorkflow(),generateCodegenPorcelainWorkflow(),...Object.entries(getYarnWorkspaceWorkflows())].map(([e,n])=>({pathForGeneratedCode:`.github/workflows/generated-${e}.yml`,generatedCode:githubActionWorkflowToString(n)}))};var O=j;const _=Object(o["readFileSync"])(".gitignore");const k=Object(o["readFileSync"])("configuration/styleignore.additions");const S=`# @generated\n\n${_}\n${k}`;const $={serviceName:"Generate ignore files derived from .gitignore",generatedCodeContentList:[{pathForGeneratedCode:".eslintignore",generatedCode:S},{pathForGeneratedCode:".prettierignore",generatedCode:S}]};var E=$;const v=[O,E];const executeCodegenServices=()=>{v.forEach(e=>{const{generatedFilenamePattern:n,generatedCodeContentList:t}=e;if(n!=null){Object(r["spawnSync"])("git",["rm",n])}const c=t.map(({pathForGeneratedCode:e,generatedCode:n})=>{Object(o["writeFileSync"])(e,n);return e});Object(r["spawnSync"])("git",["add",...c])})};var C=executeCodegenServices;const N=Object(c["join"])(".monorail","incremental-compile.json");const getIncrementalCompileLastRunTime=()=>{if(!Object(o["existsSync"])(N)){return 0}return Number(JSON.parse(Object(o["readFileSync"])(N).toString()).lastRunTime)};const setIncrementalCompileLastRunTime=()=>{Object(o["mkdirSync"])(Object(c["dirname"])(N),{recursive:true});Object(o["writeFileSync"])(N,JSON.stringify({lastRunTime:(new Date).getTime()},undefined,2))};const incrementalCompile=async()=>{console.log("--- Monorail Incremental Compile Service ---");const e=getIncrementalCompileLastRunTime();const needToRecompileLocalCheck=n=>u(n,[],e);const needToRecompileCICheck=e=>Object(r["spawnSync"])("git",["diff","HEAD^","HEAD","--name-only",getYarnWorkspaceLocation(e)]).stdout.toString().trim().length>0;const n=process.env.CI?needToRecompileCICheck:needToRecompileLocalCheck;const t=getYarnWorkspacesInTopologicalOrder().filter(getYarnWorkspaceHasCompileScript).filter(n);if(t.length===0){console.log("[✓] Nothing needs to be recompiled!");return}console.group(`[${t.join(", ")}] needs to be re-compiled!`);const o=await Promise.all(t.map(e=>{console.log(`Compiling \`${e}\`...`);const n=Object(r["spawn"])("yarn",["workspace",e,"compile"]);return new Promise(t=>{n.on("exit",n=>t([e,n===0]))})}));console.groupEnd();const c=o.filter(([,e])=>!e).map(([e])=>e);if(c.length===0){console.log("[✓] All workspaces have been successfully compiled!");setIncrementalCompileLastRunTime();return}throw new Error(`[x] [${c.join(", ")}] failed to exit with 0`)};var R=incrementalCompile;const checkThatThereIsNoChangedFiles=()=>{const e=Object(r["spawnSync"])("git",["status","--porcelain"],{shell:true}).stdout.toString();if(e.length===0)return;throw new Error(`There are changed files! Generated files might be out-of-sync!\n${e.trimEnd()}`)};var x=checkThatThereIsNoChangedFiles;const safeCopy=(e,n)=>{Object(o["mkdirSync"])(Object(c["dirname"])(n),{recursive:true});Object(o["copyFileSync"])(e,n)};const normalizedCommandForPrint=e=>e.map(e=>e.includes(" ")?`"${e}"`:e).join(" ");const synchronizeToRepository=(e,n)=>{Object.entries(n).forEach(([n,t])=>{safeCopy(n,Object(c["join"])("..",e,t))});console.log(`[✓] Synced files to target repository \`${e}\`.`);const t=Object(c["resolve"])(Object(c["join"])("..",e));if(Object(r["spawnSync"])("git",["status","--porcelain"],{cwd:t}).stdout.toString().trim()===""){console.log(`[✓] Target repository \`${e}\` is already in a clean state. Skip.`);return}const o=Object.values(n);const s=[["git","checkout","-b",`monorail/sync-service/t-${(new Date).getTime()}`],["git","add",...o],["git","commit","-m",`[monorail-sync] Automatic file sync commit from ${Object(c["basename"])(Object(c["resolve"])("."))}`],["gh","pr","create","--fill"]];console.group(`[✓] Making a pull request for synchronized files in \`${e}\`.`);if(process.env.DRY_RUN){s.forEach(e=>console.log(`> ${normalizedCommandForPrint(e)}`));console.groupEnd();console.log(`[✓] DRY_RUN for making PR for \`${e}\` completed.`)}else{s.forEach(e=>{const n=normalizedCommandForPrint(e);console.group(`> ${n}`);const o=Object(r["spawnSync"])(e[0],e.slice(1),{cwd:t});console.group();const pipeOutput=(e,n)=>{const t=e.toString().trim();if(!t)return;t.split("\n").filter(Boolean).forEach(e=>n?console.error(e):console.log(e))};if(o.status!==0||process.env.INCLUDE_ERROR){pipeOutput(o.stderr,true)}pipeOutput(o.stdout,false);console.groupEnd();console.groupEnd();if(o.status!==0){throw new Error(`Failed to run: \`${e}\``)}});console.groupEnd();console.log(`\n[✓] Made a pull request for synchronized files in \`${e}\`.`)}};const synchronize=()=>{const e=Object(c["join"])("configuration","sync-configuration.json");if(!Object(o["existsSync"])(e)){return}console.group("--- Monorail Cross-repository Sync Service ---");const n=JSON.parse(Object(o["readFileSync"])(e).toString());Object.entries(n).forEach(([e,n])=>{console.group(`\nSynchronizing for \`${e}\`...`);synchronizeToRepository(e,n);console.groupEnd()});console.groupEnd();console.log(`\n[✓] Synchronized all files.`)};var T=synchronize;try{process.chdir(t(4).PROJECT_ROOT_DIRECTORY)}catch(e){console.error(e.message);process.exit(1)}const main=async()=>{try{switch(g()){case"CODEGEN":C();return;case"COMPILE":await R();return;case"NO_CHANGED":x();return;case"REBUILD":await d();return;case"SYNC":T();return;default:throw new Error}}catch(e){console.error(e.message);process.exit(1)}};main()}]);